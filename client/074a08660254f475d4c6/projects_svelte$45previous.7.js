(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{22:function(e,t,c){"use strict";c.r(t),c.d(t,"META",(function(){return r}));var a=c(0),b=c(8),j=c(7);function O(e){let t,c,j,O,r,i,l,h,d,p,g,m,v,y,u,f,w,I,z,E,x,k,q,S,X,D,V,T,P,H,$,C,W,G,N,A,R,M,L,F,J,U,_,Q,B,K,Y,Z,ee,te,ce,ae,be,je,Oe,re,oe,ne,se,ie,le,he,de,pe,ge,me,ve,ye,ue,fe,we,Ie,ze,Ee,xe,ke,qe,Se,Xe,De,Ve,Te,Pe,He,$e,Ce,We,Ge,Ne,Ae,Re,Me,Le,Fe,Je,Ue,_e,Qe,Be,Ke,Ye,Ze,et,tt,ct,at,bt,jt,Ot,rt,ot,nt;return ke=new b.a({props:{tech:e[1],class:"flex justify-center h-12"}}),{c(){t=Object(a.X)(),c=Object(a.z)("div"),j=Object(a.z)("div"),O=Object(a.z)("h2"),r=Object(a.ab)(e[0]),i=Object(a.X)(),l=Object(a.z)("div"),h=Object(a.ab)("Svelte Stores that remember previous values!"),d=Object(a.X)(),p=Object(a.z)("img"),m=Object(a.X)(),v=Object(a.z)("div"),y=Object(a.z)("p"),u=Object(a.ab)("Some time back, I was trying to re-create a "),f=Object(a.z)("strong"),w=Object(a.ab)("fancy"),I=Object(a.ab)(" animation I had seen\nfrom Cyberpunk 2077:"),z=Object(a.X)(),E=Object(a.z)("div"),x=Object(a.z)("p"),k=Object(a.ab)("When doing so, I found myself needing the previous value of the text\nproperty when creating the transition. In fact, I realized that it would be\nquite common to need a reference to the old value of a newly changed\nproperty in Svelte. However, there was no simple or clean solution at the\ntime."),q=Object(a.X)(),S=Object(a.z)("div"),X=Object(a.z)("p"),D=Object(a.ab)("In Svelte, when we need custom behaviour from our data, we should use\n"),V=Object(a.z)("a"),T=Object(a.ab)("Svelte Stores"),P=Object(a.ab)("! Therefore, I\ndeveloped this package to provide the most Svelte-like way of handling such\nbehaviour."),H=Object(a.X)(),$=Object(a.z)("div"),C=Object(a.z)("a"),W=Object(a.ab)("Check it out on Github"),G=Object(a.X)(),N=Object(a.z)("hr"),A=Object(a.X)(),R=Object(a.z)("div"),M=Object(a.z)("div"),L=Object(a.z)("h3"),F=Object(a.ab)("How it works"),J=Object(a.X)(),U=Object(a.z)("div"),_=Object(a.z)("p"),Q=Object(a.ab)("The package returns an array of stores — the first being a writable\nstore and the rest being read-only."),B=Object(a.X)(),Y=Object(a.X)(),Z=Object(a.z)("div"),ee=Object(a.z)("p"),te=Object(a.ab)("When the stores are initialized, an internal store is created to keep track\nof all revisions made to the value. When the value is updated, we only have\nto increase the index of all revisions by one, and add the new value to the\nhead of the array."),ce=Object(a.X)(),ae=Object(a.z)("div"),be=Object(a.z)("p"),je=Object(a.ab)("To create individual stores from the array store, we can use an underlooked\nfeature of Svelte Stores — "),Oe=Object(a.z)("a"),re=Object(a.ab)("derived\nstores"),oe=Object(a.ab)("."),ne=Object(a.X)(),se=Object(a.z)("div"),ie=Object(a.z)("p"),le=Object(a.ab)("We can simply derive stores for each element of the array, and give the\nfirst store a "),he=Object(a.z)("code"),de=Object(a.ab)("set"),pe=Object(a.ab)(" and "),ge=Object(a.z)("code"),me=Object(a.ab)("update"),ve=Object(a.ab)(" function to make it a writable store."),ye=Object(a.X)(),ue=Object(a.z)("hr"),fe=Object(a.X)(),we=Object(a.z)("div"),Ie=Object(a.z)("div"),ze=Object(a.z)("h3"),Ee=Object(a.ab)("Lessons learnt"),xe=Object(a.X)(),Object(a.s)(ke.$$.fragment),qe=Object(a.X)(),Se=Object(a.z)("div"),Xe=Object(a.z)("p"),De=Object(a.ab)("This project was written in "),Ve=Object(a.z)("strong"),Te=Object(a.ab)("Typescript"),Pe=Object(a.ab)(", as I truly enjoy the powerful\ntype system. It also gave me another chance to brush up on my understanding\nof "),He=Object(a.z)("strong"),$e=Object(a.ab)("Svelte"),Ce=Object(a.ab)(" and the state management functionality provided by stores."),We=Object(a.X)(),Ge=Object(a.z)("div"),Ne=Object(a.z)("p"),Ae=Object(a.ab)("More importantly, this project reminded me that the most crucial step in\ndesigning a package is the planning phase before any code is written."),Re=Object(a.X)(),Me=Object(a.z)("div"),Le=Object(a.z)("p"),Fe=Object(a.ab)("From the start, I knew that I did not want a difference in data type between\nwriting a value and reading the value from the store. Therefore, I ruled out\nsuch an interface early on:"),Je=Object(a.X)(),_e=Object(a.X)(),Qe=Object(a.z)("div"),Be=Object(a.ab)("I toyed with the idea of providing a "),Ke=Object(a.z)("code"),Ye=Object(a.ab)(".setCurrent"),Ze=Object(a.ab)(" method on the store:"),et=Object(a.X)(),ct=Object(a.X)(),at=Object(a.z)("div"),bt=Object(a.z)("p"),jt=Object(a.ab)("However, the syntax becomes awkward, and it is "),Ot=Object(a.z)("strong"),rt=Object(a.ab)("easy to make mistakes"),ot=Object(a.ab)("\nwhen setting the current value. Ultimately, I decided on using a helper\nfunction to instantiate multiple stores that would be coupled together,\nwhich produced the current API design."),this.h()},l(b){Object(a.Q)('[data-svelte="svelte-12dosci"]',document.head).forEach(a.y),t=Object(a.p)(b),c=Object(a.o)(b,"DIV",{class:!0});var o=Object(a.m)(c);j=Object(a.o)(o,"DIV",{class:!0});var n=Object(a.m)(j);O=Object(a.o)(n,"H2",{});var s=Object(a.m)(O);r=Object(a.q)(s,e[0]),s.forEach(a.y),n.forEach(a.y),i=Object(a.p)(o),l=Object(a.o)(o,"DIV",{class:!0});var g=Object(a.m)(l);h=Object(a.q)(g,"Svelte Stores that remember previous values!"),g.forEach(a.y),d=Object(a.p)(o),p=Object(a.o)(o,"IMG",{src:!0,alt:!0,class:!0}),m=Object(a.p)(o),v=Object(a.o)(o,"DIV",{class:!0});var K=Object(a.m)(v);y=Object(a.o)(K,"P",{});var Ue=Object(a.m)(y);u=Object(a.q)(Ue,"Some time back, I was trying to re-create a "),f=Object(a.o)(Ue,"STRONG",{});var tt=Object(a.m)(f);w=Object(a.q)(tt,"fancy"),tt.forEach(a.y),I=Object(a.q)(Ue," animation I had seen\nfrom Cyberpunk 2077:"),Ue.forEach(a.y),K.forEach(a.y),z=Object(a.p)(o),E=Object(a.o)(o,"DIV",{class:!0});var nt=Object(a.m)(E);x=Object(a.o)(nt,"P",{});var st=Object(a.m)(x);k=Object(a.q)(st,"When doing so, I found myself needing the previous value of the text\nproperty when creating the transition. In fact, I realized that it would be\nquite common to need a reference to the old value of a newly changed\nproperty in Svelte. However, there was no simple or clean solution at the\ntime."),st.forEach(a.y),nt.forEach(a.y),q=Object(a.p)(o),S=Object(a.o)(o,"DIV",{class:!0});var it=Object(a.m)(S);X=Object(a.o)(it,"P",{});var lt=Object(a.m)(X);D=Object(a.q)(lt,"In Svelte, when we need custom behaviour from our data, we should use\n"),V=Object(a.o)(lt,"A",{href:!0});var ht=Object(a.m)(V);T=Object(a.q)(ht,"Svelte Stores"),ht.forEach(a.y),P=Object(a.q)(lt,"! Therefore, I\ndeveloped this package to provide the most Svelte-like way of handling such\nbehaviour."),lt.forEach(a.y),it.forEach(a.y),o.forEach(a.y),H=Object(a.p)(b),$=Object(a.o)(b,"DIV",{class:!0});var dt=Object(a.m)($);C=Object(a.o)(dt,"A",{href:!0,class:!0});var pt=Object(a.m)(C);W=Object(a.q)(pt,"Check it out on Github"),pt.forEach(a.y),dt.forEach(a.y),G=Object(a.p)(b),N=Object(a.o)(b,"HR",{}),A=Object(a.p)(b),R=Object(a.o)(b,"DIV",{class:!0});var gt=Object(a.m)(R);M=Object(a.o)(gt,"DIV",{class:!0});var mt=Object(a.m)(M);L=Object(a.o)(mt,"H3",{});var vt=Object(a.m)(L);F=Object(a.q)(vt,"How it works"),vt.forEach(a.y),mt.forEach(a.y),J=Object(a.p)(gt),U=Object(a.o)(gt,"DIV",{class:!0});var yt=Object(a.m)(U);_=Object(a.o)(yt,"P",{});var ut=Object(a.m)(_);Q=Object(a.q)(ut,"The package returns an array of stores — the first being a writable\nstore and the rest being read-only."),ut.forEach(a.y),yt.forEach(a.y),B=Object(a.p)(gt),Y=Object(a.p)(gt),Z=Object(a.o)(gt,"DIV",{class:!0});var ft=Object(a.m)(Z);ee=Object(a.o)(ft,"P",{});var wt=Object(a.m)(ee);te=Object(a.q)(wt,"When the stores are initialized, an internal store is created to keep track\nof all revisions made to the value. When the value is updated, we only have\nto increase the index of all revisions by one, and add the new value to the\nhead of the array."),wt.forEach(a.y),ft.forEach(a.y),ce=Object(a.p)(gt),ae=Object(a.o)(gt,"DIV",{class:!0});var It=Object(a.m)(ae);be=Object(a.o)(It,"P",{});var zt=Object(a.m)(be);je=Object(a.q)(zt,"To create individual stores from the array store, we can use an underlooked\nfeature of Svelte Stores — "),Oe=Object(a.o)(zt,"A",{href:!0});var Et=Object(a.m)(Oe);re=Object(a.q)(Et,"derived\nstores"),Et.forEach(a.y),oe=Object(a.q)(zt,"."),zt.forEach(a.y),It.forEach(a.y),ne=Object(a.p)(gt),se=Object(a.o)(gt,"DIV",{class:!0});var xt=Object(a.m)(se);ie=Object(a.o)(xt,"P",{});var kt=Object(a.m)(ie);le=Object(a.q)(kt,"We can simply derive stores for each element of the array, and give the\nfirst store a "),he=Object(a.o)(kt,"CODE",{});var qt=Object(a.m)(he);de=Object(a.q)(qt,"set"),qt.forEach(a.y),pe=Object(a.q)(kt," and "),ge=Object(a.o)(kt,"CODE",{});var St=Object(a.m)(ge);me=Object(a.q)(St,"update"),St.forEach(a.y),ve=Object(a.q)(kt," function to make it a writable store."),kt.forEach(a.y),xt.forEach(a.y),gt.forEach(a.y),ye=Object(a.p)(b),ue=Object(a.o)(b,"HR",{}),fe=Object(a.p)(b),we=Object(a.o)(b,"DIV",{class:!0});var Xt=Object(a.m)(we);Ie=Object(a.o)(Xt,"DIV",{class:!0});var Dt=Object(a.m)(Ie);ze=Object(a.o)(Dt,"H3",{});var Vt=Object(a.m)(ze);Ee=Object(a.q)(Vt,"Lessons learnt"),Vt.forEach(a.y),Dt.forEach(a.y),xe=Object(a.p)(Xt),Object(a.n)(ke.$$.fragment,Xt),qe=Object(a.p)(Xt),Se=Object(a.o)(Xt,"DIV",{class:!0});var Tt=Object(a.m)(Se);Xe=Object(a.o)(Tt,"P",{});var Pt=Object(a.m)(Xe);De=Object(a.q)(Pt,"This project was written in "),Ve=Object(a.o)(Pt,"STRONG",{});var Ht=Object(a.m)(Ve);Te=Object(a.q)(Ht,"Typescript"),Ht.forEach(a.y),Pe=Object(a.q)(Pt,", as I truly enjoy the powerful\ntype system. It also gave me another chance to brush up on my understanding\nof "),He=Object(a.o)(Pt,"STRONG",{});var $t=Object(a.m)(He);$e=Object(a.q)($t,"Svelte"),$t.forEach(a.y),Ce=Object(a.q)(Pt," and the state management functionality provided by stores."),Pt.forEach(a.y),Tt.forEach(a.y),We=Object(a.p)(Xt),Ge=Object(a.o)(Xt,"DIV",{class:!0});var Ct=Object(a.m)(Ge);Ne=Object(a.o)(Ct,"P",{});var Wt=Object(a.m)(Ne);Ae=Object(a.q)(Wt,"More importantly, this project reminded me that the most crucial step in\ndesigning a package is the planning phase before any code is written."),Wt.forEach(a.y),Ct.forEach(a.y),Re=Object(a.p)(Xt),Me=Object(a.o)(Xt,"DIV",{class:!0});var Gt=Object(a.m)(Me);Le=Object(a.o)(Gt,"P",{});var Nt=Object(a.m)(Le);Fe=Object(a.q)(Nt,"From the start, I knew that I did not want a difference in data type between\nwriting a value and reading the value from the store. Therefore, I ruled out\nsuch an interface early on:"),Nt.forEach(a.y),Gt.forEach(a.y),Je=Object(a.p)(Xt),_e=Object(a.p)(Xt),Qe=Object(a.o)(Xt,"DIV",{class:!0});var At=Object(a.m)(Qe);Be=Object(a.q)(At,"I toyed with the idea of providing a "),Ke=Object(a.o)(At,"CODE",{});var Rt=Object(a.m)(Ke);Ye=Object(a.q)(Rt,".setCurrent"),Rt.forEach(a.y),Ze=Object(a.q)(At," method on the store:"),At.forEach(a.y),et=Object(a.p)(Xt),ct=Object(a.p)(Xt),at=Object(a.o)(Xt,"DIV",{class:!0});var Mt=Object(a.m)(at);bt=Object(a.o)(Mt,"P",{});var Lt=Object(a.m)(bt);jt=Object(a.q)(Lt,"However, the syntax becomes awkward, and it is "),Ot=Object(a.o)(Lt,"STRONG",{});var Ft=Object(a.m)(Ot);rt=Object(a.q)(Ft,"easy to make mistakes"),Ft.forEach(a.y),ot=Object(a.q)(Lt,"\nwhen setting the current value. Ultimately, I decided on using a helper\nfunction to instantiate multiple stores that would be coupled together,\nwhich produced the current API design."),Lt.forEach(a.y),Mt.forEach(a.y),Xt.forEach(a.y),this.h()},h(){document.title="svelte-previous",Object(a.i)(j,"class","font-mono text-center"),Object(a.i)(l,"class","text-center italic"),p.src!==(g=e[2])&&Object(a.i)(p,"src",g),Object(a.i)(p,"alt",e[0]),Object(a.i)(p,"class","mx-auto max-h-48"),Object(a.i)(v,"class","px-3 py-1 card leading-8"),Object(a.i)(E,"class","px-3 py-1 card leading-8"),Object(a.i)(V,"href","https://svelte.dev/tutorial/writable-stores"),Object(a.i)(S,"class","px-3 py-1 card leading-8"),Object(a.i)(c,"class","mx-auto my-10 prose space-y-3"),Object(a.i)(C,"href",e[3]),Object(a.i)(C,"class","p-3 italic font-bold cta-button"),Object(a.i)($,"class","flex justify-center my-10"),Object(a.i)(M,"class","font-mono text-center"),Object(a.i)(U,"class","px-3 py-1 card leading-8"),K=new a.a(Y),Object(a.i)(Z,"class","px-3 py-1 card leading-8"),Object(a.i)(Oe,"href","https://svelte.dev/tutorial/derived-stores"),Object(a.i)(ae,"class","px-3 py-1 card leading-8"),Object(a.i)(se,"class","px-3 py-1 card leading-8"),Object(a.i)(R,"class","mx-auto my-10 prose space-y-3"),Object(a.i)(Ie,"class","font-mono text-center"),Object(a.i)(Se,"class","px-3 py-1 card leading-8"),Object(a.i)(Ge,"class","px-3 py-1 card leading-8"),Object(a.i)(Me,"class","px-3 py-1 card leading-8"),Ue=new a.a(_e),Object(a.i)(Qe,"class","px-3 py-1 card leading-8"),tt=new a.a(ct),Object(a.i)(at,"class","px-3 py-1 card leading-8"),Object(a.i)(we,"class","mx-auto my-10 prose space-y-3")},m(e,b){Object(a.I)(e,t,b),Object(a.I)(e,c,b),Object(a.g)(c,j),Object(a.g)(j,O),Object(a.g)(O,r),Object(a.g)(c,i),Object(a.g)(c,l),Object(a.g)(l,h),Object(a.g)(c,d),Object(a.g)(c,p),Object(a.g)(c,m),Object(a.g)(c,v),Object(a.g)(v,y),Object(a.g)(y,u),Object(a.g)(y,f),Object(a.g)(f,w),Object(a.g)(y,I),Object(a.g)(c,z),Object(a.g)(c,E),Object(a.g)(E,x),Object(a.g)(x,k),Object(a.g)(c,q),Object(a.g)(c,S),Object(a.g)(S,X),Object(a.g)(X,D),Object(a.g)(X,V),Object(a.g)(V,T),Object(a.g)(X,P),Object(a.I)(e,H,b),Object(a.I)(e,$,b),Object(a.g)($,C),Object(a.g)(C,W),Object(a.I)(e,G,b),Object(a.I)(e,N,b),Object(a.I)(e,A,b),Object(a.I)(e,R,b),Object(a.g)(R,M),Object(a.g)(M,L),Object(a.g)(L,F),Object(a.g)(R,J),Object(a.g)(R,U),Object(a.g)(U,_),Object(a.g)(_,Q),Object(a.g)(R,B),K.m(o,R),Object(a.g)(R,Y),Object(a.g)(R,Z),Object(a.g)(Z,ee),Object(a.g)(ee,te),Object(a.g)(R,ce),Object(a.g)(R,ae),Object(a.g)(ae,be),Object(a.g)(be,je),Object(a.g)(be,Oe),Object(a.g)(Oe,re),Object(a.g)(be,oe),Object(a.g)(R,ne),Object(a.g)(R,se),Object(a.g)(se,ie),Object(a.g)(ie,le),Object(a.g)(ie,he),Object(a.g)(he,de),Object(a.g)(ie,pe),Object(a.g)(ie,ge),Object(a.g)(ge,me),Object(a.g)(ie,ve),Object(a.I)(e,ye,b),Object(a.I)(e,ue,b),Object(a.I)(e,fe,b),Object(a.I)(e,we,b),Object(a.g)(we,Ie),Object(a.g)(Ie,ze),Object(a.g)(ze,Ee),Object(a.g)(we,xe),Object(a.L)(ke,we,null),Object(a.g)(we,qe),Object(a.g)(we,Se),Object(a.g)(Se,Xe),Object(a.g)(Xe,De),Object(a.g)(Xe,Ve),Object(a.g)(Ve,Te),Object(a.g)(Xe,Pe),Object(a.g)(Xe,He),Object(a.g)(He,$e),Object(a.g)(Xe,Ce),Object(a.g)(we,We),Object(a.g)(we,Ge),Object(a.g)(Ge,Ne),Object(a.g)(Ne,Ae),Object(a.g)(we,Re),Object(a.g)(we,Me),Object(a.g)(Me,Le),Object(a.g)(Le,Fe),Object(a.g)(we,Je),Ue.m(n,we),Object(a.g)(we,_e),Object(a.g)(we,Qe),Object(a.g)(Qe,Be),Object(a.g)(Qe,Ke),Object(a.g)(Ke,Ye),Object(a.g)(Qe,Ze),Object(a.g)(we,et),tt.m(s,we),Object(a.g)(we,ct),Object(a.g)(we,at),Object(a.g)(at,bt),Object(a.g)(bt,jt),Object(a.g)(bt,Ot),Object(a.g)(Ot,rt),Object(a.g)(bt,ot),nt=!0},p:a.M,i(e){nt||(Object(a.cb)(ke.$$.fragment,e),nt=!0)},o(e){Object(a.db)(ke.$$.fragment,e),nt=!1},d(e){e&&Object(a.y)(t),e&&Object(a.y)(c),e&&Object(a.y)(H),e&&Object(a.y)($),e&&Object(a.y)(G),e&&Object(a.y)(N),e&&Object(a.y)(A),e&&Object(a.y)(R),e&&Object(a.y)(ye),e&&Object(a.y)(ue),e&&Object(a.y)(fe),e&&Object(a.y)(we),Object(a.w)(ke)}}}const r={},o='<pre><code class="language-ts">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;bryan&#x27;</span>;\n  <span class="hljs-keyword">const</span> [currentName, previousName] = withPrevious(name);</code></pre>\n',n='<pre><code class="language-ts">  $name = <span class="hljs-string">&#x27;adam&#x27;</span>;\n  <span class="hljs-built_in">console</span>.log($name); <span class="hljs-comment">// &#123; current: &#x27;adam&#x27;, previous: &#x27;bryan&#x27; &#125;</span></code></pre>\n',s='<pre><code class="language-ts">  name.setCurrent(<span class="hljs-string">&#x27;adam&#x27;</span>);\n  <span class="hljs-built_in">console</span>.log($name); <span class="hljs-comment">// &#123; current: &#x27;adam&#x27;, previous: &#x27;bryan&#x27; &#125;</span></code></pre>\n';function i(e){const{projectName:t,tech:c,logo:a,github:b}=j.a.projects["svelte-previous"];return[t,c,a,b]}class l extends a.b{constructor(e){super(),Object(a.H)(this,e,i,O,a.S,{})}}t.default=l}}]);